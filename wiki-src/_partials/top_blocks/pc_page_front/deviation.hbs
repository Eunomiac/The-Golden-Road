<div class="block top-block deviation-block">
  <div class="form-label form-label-title">Scars & Variations:</div>

  <div class="deviation-columns">
      {{#with (lookup variationsByScar "__ungrouped__") as |standaloneVariations|}}
        {{#if standaloneVariations}}
          <div class="standalone-variation-list" data-variation-group>
            {{#each standaloneVariations}}
              {{> _partials/advantage/variation-card variation=this isSub=false}}
            {{/each}}
          </div>
        {{/if}}
      {{/with}}
      {{#if scars}}
        {{#each scars}}
          <article class="scar-entry" data-scar-key="{{key}}">
            {{#if deviationBadges}}
              <div class="scar-deviation-badge-row" aria-hidden="true" style="opacity: 0;">
                {{#each deviationBadges}}
                  <span class="scar-deviation-badge">{{{html}}}</span>
                {{/each}}
              </div>
            {{/if}}
            <div class="scar-header" role="button" tabindex="0" aria-expanded="false">
              <div class="scar-deviation-tags">
                {{#each tags}}
                  <span class="scar-deviation-tag" magMod="{{magMod}}">{{display}}</span>
                {{/each}}
              </div>
              <div class="scar-title-row">
                <span class="scar-name">
                  {{#tagged tags=activationTags}}
                    {{{display}}}
                  {{/tagged}}
                </span>
                <span class="scar-meta">
                  {{#if valueDots}}
                    <span class="scar-value dotline">
                      {{#each valueDots}}
                        <span class="dot {{this}}"></span>
                      {{/each}}
                    </span>
                  {{else}}
                    <span class="scar-level">Tier {{purchaseLevel}}</span>
                  {{/if}}
                </span>
              </div>
            </div>
            {{#if narrative}}
              <div class="scar-narrative{{#if narrativeClass}} {{narrativeClass}}{{/if}}">
                {{{narrative}}}
              </div>
            {{/if}}
            <div class="scar-content">
              {{#if infoLine}}
                <div class="scar-info-line">
                  {{#if infoLine.activationHtml}}
                    <span class="scar-info-item scar-info-activation">{{{infoLine.activationHtml}}}</span>
                  {{/if}}
                  <span class="scar-info-item scar-info-type">{{infoLine.typeLabel}}</span>
                  {{#each infoLine.stats}}
                    <span class="scar-info-item scar-info-stat">
                      <span class="scar-info-label">{{label}}</span>
                      <span class="scar-info-value">{{{valueHtml}}}</span>
                    </span>
                  {{/each}}
                </div>
              {{/if}}
              {{#if keywordBadges}}
                <div class="adv-keyword-row">
                  {{#each keywordBadges}}
                    <span class="adv-keyword-pill {{className}}">{{{html}}}</span>
                  {{/each}}
                </div>
              {{/if}}
              {{#if effect}}
                <div class="scar-effect">
                  {{{effect}}}
                </div>
              {{/if}}
              {{#if source}}
                <div class="scar-source">
                  {{> _partials/source-citation source=source}}
                </div>
              {{/if}}
            </div>
            {{#with (lookup ../variationsByScar key) as |scarVariations|}}
              {{#if scarVariations}}
                <div class="scar-variations" data-variation-group>
                  {{#each scarVariations}}
                    {{> _partials/advantage/variation-card variation=this isSub=false}}
                  {{/each}}
                </div>
              {{/if}}
            {{/with}}
          </article>
        {{/each}}
      {{/if}}
  </div>
</div>

<script type="module">
  import { gsap } from "gsap";

  const deviationBlock = document.querySelector(".deviation-block");

  if (deviationBlock) {
    const accordionRegistry = (() => {
      let currentEntry = null;
      return {
        requestOpen(item, closeFn) {
          // If there's a current entry and it's different from the one being opened
          if (currentEntry && currentEntry.item !== item) {
            // Close the current entry first
            currentEntry.close(false);
          }
          // Set the new current entry
          currentEntry = { item, close: closeFn };
        },
        notifyClosed(item) {
          // Only clear currentEntry if it matches the item that was closed
          // This prevents clearing the entry if a new item was opened while the old one was closing
          if (currentEntry && currentEntry.item === item) {
            currentEntry = null;
          }
        },
        getCurrentEntry() {
          return currentEntry;
        },
        isVariationOpen() {
          // Check if the current entry is a variation (not a scar)
          if (!currentEntry) {
            return false;
          }
          return currentEntry.item.classList.contains("variation-entry");
        }
      };
    })();

    const createAccordion = (items, selectors, options = {}, registry = null) => {
      const groupItems = Array.from(items);
      if (groupItems.length === 0) {
        return null;
      }

      let openItem = null;

      const closePanel = (item, instant = false) => {
        const header = item.querySelector(selectors.header);
        const content = item.querySelector(selectors.content);
        const narrative = selectors.narrative ? item.querySelector(selectors.narrative) : null;
        // Find badge row that is the immediately preceding sibling of the header
        const badgeRow = selectors.badges && header ? (() => {
          let prev = header.previousElementSibling;
          while (prev) {
            if (prev.matches(selectors.badges)) {
              return prev;
            }
            prev = prev.previousElementSibling;
          }
          return null;
        })() : null;

        if (!header || !content) {
          return;
        }

        header.setAttribute("aria-expanded", "false");

        if (instant) {
          content.style.opacity = 0;
          content.style.height = 0;
          content.style.overflow = "hidden";
          if (narrative) {
            narrative.style.opacity = 0;
            narrative.style.height = "auto";
            narrative.style.overflow = "";
          }
          if (badgeRow) {
            badgeRow.style.opacity = 0;
          }
          if (openItem === item) {
            openItem = null;
          }
          if (typeof options.onClose === "function") {
            options.onClose(item, true);
          }
          if (registry) {
            registry.notifyClosed(item);
          }
          return;
        }

        const contentHeight = content.offsetHeight;
        content.style.height = `${contentHeight}px`;
        content.style.overflow = "hidden";

        const closingTimeline = gsap.timeline({
          onComplete: () => {
            content.style.display = "block";
            content.style.opacity = "0";
            content.style.height = "0";
            content.style.overflow = "hidden";
            // Only clear openItem if this item is still the one that was being closed
            // This prevents clearing it if a new item was opened during the closing animation
            if (openItem === item) {
              openItem = null;
            }
            if (typeof options.onClose === "function") {
              options.onClose(item, false);
            }
            if (registry) {
              registry.notifyClosed(item);
            }
          }
        });

        closingTimeline.to(content, {
          opacity: 0,
          height: 0,
          duration: 0.3,
          ease: "power2.in"
        });

        if (narrative) {
          narrative.style.display = "block";
          const narrativeHeight = narrative.scrollHeight;
          closingTimeline.to(narrative, {
            opacity: 1,
            height: narrativeHeight,
            marginBottom: 14,
            duration: 0.4,
            ease: "power2.out",
            onComplete: () => {
              narrative.style.height = "auto";
              narrative.style.overflow = "";
            }
          }, "-=0.1");
        }

        if (badgeRow) {
          badgeRow.style.overflow = "hidden";
          closingTimeline.to(header, {
            marginTop: 0,
            duration: 0.2,
            ease: "power2.in"
          }, 0)
          closingTimeline.to(badgeRow, {
            opacity: 0,
            duration: 0.2,
            ease: "power2.in"
          }, 0);
        }
      };

      const openPanel = (item, header, content, narrative) => {
        // Register with the registry first - it will handle closing any previous item
        const closeFn = (instantClose = false) => closePanel(item, instantClose);
        // Find badge row that is the immediately preceding sibling of the header
        const badgeRow = selectors.badges && header ? (() => {
          let prev = header.previousElementSibling;
          while (prev) {
            if (prev.matches(selectors.badges)) {
              return prev;
            }
            prev = prev.previousElementSibling;
          }
          return null;
        })() : null;

        if (registry) {
          registry.requestOpen(item, closeFn);
        } else if (openItem && openItem !== item) {
          // If no registry, close the previous item directly
          closePanel(openItem);
        }

        // Set the open item after registering, so the closing animation knows not to reset it
        openItem = item;
        header.setAttribute("aria-expanded", "true");

        content.style.display = "block";
        content.style.opacity = "0";
        content.style.height = "0";
        content.style.overflow = "hidden";
        content.style.pointerEvents = "none";

        const openingTimeline = gsap.timeline();

        if (narrative) {
          const narrativeHeight = narrative.offsetHeight;
          narrative.style.height = `${narrativeHeight}px`;
          narrative.style.overflow = "hidden";
          openingTimeline.to(narrative, {
            marginBottom: 0,
            opacity: 0,
            height: 0,
            duration: 0.3,
            ease: "power2.in",
            onComplete: () => {
              narrative.style.display = "block";
              narrative.style.opacity = "0";
              narrative.style.height = "0";
              narrative.style.overflow = "hidden";
              narrative.style.pointerEvents = "none";
            }
          });
        }

        if (badgeRow) {
          badgeRow.style.overflow = "hidden";
          openingTimeline.to(header, {
            marginTop: 35,
            duration: 0.25,
            ease: "power2.out"
          }, 0)
          openingTimeline.fromTo(badgeRow, {
            opacity: 0,
            top: 47
          },
          {
            opacity: 1,
            top: 28,
            duration: 0.25,
            ease: "power2.out",
            onComplete: () => {
              badgeRow.style.overflow = "";
            }
          }, 0);
        }

        // Measure content height - since narrative and content are now siblings,
        // we can measure after narrative is hidden to get accurate height
        const measureContentHeight = () => {
          if (narrative) {
            narrative.style.display = "none";
          }
          return content.scrollHeight;
        };

        // Measure content height after narrative collapses (or immediately if no narrative)
        const targetHeight = narrative
          ? measureContentHeight() // Hide narrative first, then measure
          : content.scrollHeight;

        // If we hid narrative for measurement, show it again for animation
        if (narrative) {
          narrative.style.display = "block";
          narrative.style.height = `${narrative.offsetHeight}px`;
          narrative.style.overflow = "hidden";
          narrative.style.pointerEvents = "none";
        }

        openingTimeline.to(content, {
          opacity: 1,
          height: targetHeight,
          duration: 0.4,
          ease: "power2.out",
          onComplete: () => {
            content.style.height = "auto";
            content.style.overflow = "";
            content.style.pointerEvents = "auto";
            // Scroll the opened item into view after animation completes
            scrollItemIntoView(item);
          }
        }, narrative ? "-=0.1" : 0);
      };

      /**
       * Scrolls an accordion item into view within the paper-stack-scroll container.
       * Centers the item vertically in the viewport when it's expanded.
       */
      const scrollItemIntoView = (item) => {
        const scrollContainer = document.querySelector(".paper-stack-scroll");
        if (!scrollContainer || !item) {
          return;
        }

        // Get container dimensions
        const containerHeight = scrollContainer.clientHeight;
        const containerRect = scrollContainer.getBoundingClientRect();
        const currentScrollTop = scrollContainer.scrollTop;

        // Get item's position relative to viewport
        const itemRect = item.getBoundingClientRect();

        // Calculate item's position relative to the scroll container's content
        // itemRect.top is viewport-relative, containerRect.top is also viewport-relative
        // So itemRect.top - containerRect.top gives position relative to visible container
        // Add currentScrollTop to get position relative to container's content
        const itemTopRelativeToContent = (itemRect.top - containerRect.top) + currentScrollTop;

        // Get item height
        const itemHeight = itemRect.height;

        // Calculate target scroll position to center the item vertically
        // Center = item's top position in content - (container height / 2) + (item height / 2)
        const targetScroll = itemTopRelativeToContent - (containerHeight / 2) + (itemHeight / 2);

        // Clamp the scroll position to valid bounds
        const maxScroll = scrollContainer.scrollHeight - containerHeight;
        const clampedScroll = Math.max(0, Math.min(maxScroll, targetScroll));

        // Only scroll if the target position is different from current position
        // Use a small threshold to avoid micro-scrolls
        if (Math.abs(clampedScroll - currentScrollTop) > 10) {
          // Smoothly scroll to the target position
          scrollContainer.scrollTo({
            top: clampedScroll,
            behavior: "smooth"
          });
        }
      };

      groupItems.forEach((item) => {
        const header = item.querySelector(selectors.header);
        const content = item.querySelector(selectors.content);
        const narrative = selectors.narrative ? item.querySelector(selectors.narrative) : null;

        if (!header || !content) {
          return;
        }

        const toggle = () => {
          const isExpanded = header.getAttribute("aria-expanded") === "true";
          if (isExpanded) {
            closePanel(item);
          } else {
            openPanel(item, header, content, narrative);
          }
        };

        header.addEventListener("click", toggle);
        header.addEventListener("keydown", (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            toggle();
          }
        });
      });

      return {
        closeAll(options = {}) {
          if (openItem) {
            closePanel(openItem, options.instant === true);
          }
        }
      };
    };

    const variationControllers = new WeakMap();
    const variationGroups = deviationBlock.querySelectorAll("[data-variation-group]");
    variationGroups.forEach((group) => {
      const directVariationEntries = Array.from(group.children).filter((child) =>
        child.classList.contains("variation-entry")
      );
      const controller = createAccordion(
        directVariationEntries,
        { header: ".variation-header", content: ".variation-content", narrative: ".variation-narrative", badges: ".variation-deviation-badge-row" },
        undefined,
        accordionRegistry
      );
      if (controller) {
        variationControllers.set(group, controller);
      }
    });

    createAccordion(
      deviationBlock.querySelectorAll(".scar-entry"),
      { header: ".scar-header", content: ".scar-content", narrative: ".scar-narrative", badges: ".scar-deviation-badge-row" },
      {
        onClose: (scarElement) => {
          // Only close variations if no variation is currently open in the registry
          // This prevents closing a variation that was just opened when the scar closed
          if (!accordionRegistry.isVariationOpen()) {
            scarElement.querySelectorAll("[data-variation-group]").forEach((group) => {
              variationControllers.get(group)?.closeAll({ instant: true });
            });
          }
        }
      },
      accordionRegistry
    );
  }
</script>
