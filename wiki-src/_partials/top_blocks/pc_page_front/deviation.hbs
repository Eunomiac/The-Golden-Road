<div class="block top-block deviation-block">
  <div class="form-label form-label-title">Scars & Variations:</div>

  <div class="deviation-columns">
      {{#with (lookup variationsByScar "__ungrouped__") as |standaloneVariations|}}
        {{#if standaloneVariations}}
          <div class="standalone-variation-list" data-variation-group>
            {{#each standaloneVariations}}
              {{> _partials/advantage/variation-card variation=this isSub=false}}
            {{/each}}
          </div>
        {{/if}}
      {{/with}}
      {{#if scars}}
        {{#each scars}}
          <article class="scar-entry" data-scar-key="{{key}}">
            <div class="scar-header" role="button" tabindex="0" aria-expanded="false">
              <div class="scar-deviation-tags">
                {{#each tags}}
                  <span class="scar-deviation-tag" magMod="{{magMod}}">{{display}}</span>
                {{/each}}
              </div>
              <div class="scar-title-row">
                <span class="scar-name">
                  {{#tagged tags=activationTags}}
                    {{display}}
                  {{/tagged}}
                </span>
                <span class="scar-meta">
                  {{#if valueDots}}
                    <span class="scar-value dotline">
                      {{#each valueDots}}
                        <span class="dot {{this}}"></span>
                      {{/each}}
                    </span>
                  {{else}}
                    <span class="scar-level">Tier {{purchaseLevel}}</span>
                  {{/if}}
                </span>
              </div>
              {{#if narrative}}
                <div class="scar-narrative">
                  {{{narrative}}}
                </div>
              {{/if}}
            </div>
            <div class="scar-content" style="display: none;">
              {{#if effect}}
                <div class="scar-effect">
                  {{{effect}}}
                </div>
              {{/if}}
              {{#if source}}
                <div class="scar-source">
                  {{> _partials/source-citation source=source}}
                </div>
              {{/if}}
            </div>
            {{#with (lookup ../variationsByScar key) as |scarVariations|}}
              {{#if scarVariations}}
                <div class="scar-variations" data-variation-group>
                  {{#each scarVariations}}
                    {{> _partials/advantage/variation-card variation=this isSub=false}}
                  {{/each}}
                </div>
              {{/if}}
            {{/with}}
          </article>
        {{/each}}
      {{/if}}
  </div>
</div>

<script type="module">
  import { gsap } from "gsap";

  const deviationBlock = document.querySelector(".deviation-block");

  if (deviationBlock) {
    const accordionRegistry = (() => {
      let currentEntry = null;
      return {
        requestOpen(item, closeFn) {
          // If there's a current entry and it's different from the one being opened
          if (currentEntry && currentEntry.item !== item) {
            // Close the current entry first
            currentEntry.close(false);
          }
          // Set the new current entry
          currentEntry = { item, close: closeFn };
        },
        notifyClosed(item) {
          // Only clear currentEntry if it matches the item that was closed
          // This prevents clearing the entry if a new item was opened while the old one was closing
          if (currentEntry && currentEntry.item === item) {
            currentEntry = null;
          }
        },
        getCurrentEntry() {
          return currentEntry;
        },
        isVariationOpen() {
          // Check if the current entry is a variation (not a scar)
          if (!currentEntry) {
            return false;
          }
          return currentEntry.item.classList.contains("variation-entry");
        }
      };
    })();

    const createAccordion = (items, selectors, options = {}, registry = null) => {
      const groupItems = Array.from(items);
      if (groupItems.length === 0) {
        return null;
      }

      let openItem = null;

      const closePanel = (item, instant = false) => {
        const header = item.querySelector(selectors.header);
        const content = item.querySelector(selectors.content);
        const narrative = selectors.narrative ? item.querySelector(selectors.narrative) : null;

        if (!header || !content) {
          return;
        }

        header.setAttribute("aria-expanded", "false");

        if (instant) {
          content.style.display = "none";
          content.style.opacity = "0";
          content.style.height = "";
          content.style.overflow = "";
          if (narrative) {
            narrative.style.display = "block";
            narrative.style.opacity = "1";
            narrative.style.height = "";
            narrative.style.overflow = "";
          }
          if (openItem === item) {
            openItem = null;
          }
          if (typeof options.onClose === "function") {
            options.onClose(item, true);
          }
          if (registry) {
            registry.notifyClosed(item);
          }
          return;
        }

        const contentHeight = content.offsetHeight;
        content.style.height = `${contentHeight}px`;
        content.style.overflow = "hidden";

        const closingTimeline = gsap.timeline({
          onComplete: () => {
            content.style.display = "none";
            content.style.height = "";
            content.style.overflow = "";
            // Only clear openItem if this item is still the one that was being closed
            // This prevents clearing it if a new item was opened during the closing animation
            if (openItem === item) {
              openItem = null;
            }
            if (typeof options.onClose === "function") {
              options.onClose(item, false);
            }
            if (registry) {
              registry.notifyClosed(item);
            }
          }
        });

        closingTimeline.to(content, {
          opacity: 0,
          height: 0,
          duration: 0.3,
          ease: "power2.in"
        });

        if (narrative) {
          narrative.style.display = "block";
          narrative.style.opacity = "0";
          narrative.style.height = "0";
          narrative.style.overflow = "hidden";
          const narrativeHeight = narrative.scrollHeight;
          closingTimeline.to(narrative, {
            opacity: 1,
            height: narrativeHeight,
            duration: 0.4,
            ease: "power2.out",
            onComplete: () => {
              narrative.style.height = "auto";
              narrative.style.overflow = "";
            }
          }, "-=0.1");
        }
      };

      const openPanel = (item, header, content, narrative) => {
        // Register with the registry first - it will handle closing any previous item
        const closeFn = (instantClose = false) => closePanel(item, instantClose);

        if (registry) {
          registry.requestOpen(item, closeFn);
        } else if (openItem && openItem !== item) {
          // If no registry, close the previous item directly
          closePanel(openItem);
        }

        // Set the open item after registering, so the closing animation knows not to reset it
        openItem = item;
        header.setAttribute("aria-expanded", "true");

        content.style.display = "block";
        content.style.opacity = "0";
        content.style.height = "0";
        content.style.overflow = "hidden";

        const openingTimeline = gsap.timeline();

        if (narrative) {
          const narrativeHeight = narrative.offsetHeight;
          narrative.style.height = `${narrativeHeight}px`;
          narrative.style.overflow = "hidden";
          openingTimeline.to(narrative, {
            opacity: 0,
            height: 0,
            duration: 0.3,
            ease: "power2.in",
            onComplete: () => {
              narrative.style.display = "none";
              narrative.style.height = "";
              narrative.style.overflow = "";
            }
          });
        }

        const targetHeight = content.scrollHeight;
        openingTimeline.to(content, {
          opacity: 1,
          height: targetHeight,
          duration: 0.4,
          ease: "power2.out",
          onComplete: () => {
            content.style.height = "auto";
            content.style.overflow = "";
            // Scroll the opened item into view after animation completes
            scrollItemIntoView(item);
          }
        }, narrative ? "-=0.1" : 0);
      };

      /**
       * Scrolls an accordion item into view within the paper-stack-scroll container.
       * Only scrolls if the item is near the top or bottom of the viewport, moving it towards the center.
       */
      const scrollItemIntoView = (item) => {
        const scrollContainer = document.querySelector(".paper-stack-scroll");
        if (!scrollContainer || !item) {
          return;
        }

        // Get the item's position relative to the viewport
        const itemRect = item.getBoundingClientRect();
        const containerRect = scrollContainer.getBoundingClientRect();

        const containerHeight = containerRect.height;
        const currentScrollTop = scrollContainer.scrollTop;

        // Calculate item position relative to the viewport
        const itemTopRelative = itemRect.top - containerRect.top;
        const itemBottomRelative = itemRect.bottom - containerRect.top;
        const itemHeight = itemRect.height;

        // Threshold for "near the edge" - if item is within this distance from top or bottom, scroll it
        const edgeThreshold = 150; // pixels from top/bottom edge
        const centerOffset = 50; // Extra pixels to scroll when at bottom (moves towards center)
        const topPadding = 32; // Padding when scrolling from top

        let targetScroll = currentScrollTop;
        let shouldScroll = false;

        // Check if item is near the top of the viewport
        if (itemTopRelative < edgeThreshold && itemTopRelative >= 0) {
          // Item is near the top - scroll it towards center
          // Calculate how much to scroll to move item closer to center
          const scrollAmount = edgeThreshold - itemTopRelative + topPadding;
          targetScroll = currentScrollTop - scrollAmount;
          shouldScroll = true;
        }
        // Check if item is near the bottom of the viewport
        else if (itemBottomRelative > containerHeight - edgeThreshold && itemBottomRelative <= containerHeight) {
          // Item is near the bottom - scroll it towards center with extra offset
          // Calculate how much to scroll to move item closer to center
          const scrollAmount = (containerHeight - itemBottomRelative) + edgeThreshold + centerOffset;
          targetScroll = currentScrollTop + scrollAmount;
          shouldScroll = true;
        }
        // Check if item extends beyond the viewport (partially or fully outside)
        else if (itemTopRelative < 0) {
          // Item is above the visible area - scroll to show it at the top
          const itemTopAbsolute = itemRect.top - containerRect.top + currentScrollTop;
          targetScroll = itemTopAbsolute - topPadding;
          shouldScroll = true;
        }
        else if (itemBottomRelative > containerHeight) {
          // Item extends below the visible area - scroll to show it with extra offset
          const itemTopAbsolute = itemRect.top - containerRect.top + currentScrollTop;
          targetScroll = itemTopAbsolute - (containerHeight / 2) + (itemHeight / 2) + centerOffset;
          shouldScroll = true;
        }

        // Only scroll if needed and if the target is valid
        if (shouldScroll) {
          const maxScroll = scrollContainer.scrollHeight - containerHeight;
          const clampedScroll = Math.max(0, Math.min(maxScroll, targetScroll));

          // Smoothly scroll to the target position
          scrollContainer.scrollTo({
            top: clampedScroll,
            behavior: "smooth"
          });
        }
      };

      groupItems.forEach((item) => {
        const header = item.querySelector(selectors.header);
        const content = item.querySelector(selectors.content);
        const narrative = selectors.narrative ? item.querySelector(selectors.narrative) : null;

        if (!header || !content) {
          return;
        }

        const toggle = () => {
          const isExpanded = header.getAttribute("aria-expanded") === "true";
          if (isExpanded) {
            closePanel(item);
          } else {
            openPanel(item, header, content, narrative);
          }
        };

        header.addEventListener("click", toggle);
        header.addEventListener("keydown", (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            toggle();
          }
        });
      });

      return {
        closeAll(options = {}) {
          if (openItem) {
            closePanel(openItem, options.instant === true);
          }
        }
      };
    };

    const variationControllers = new WeakMap();
    const variationGroups = deviationBlock.querySelectorAll("[data-variation-group]");
    variationGroups.forEach((group) => {
      const directVariationEntries = Array.from(group.children).filter((child) =>
        child.classList.contains("variation-entry")
      );
      const controller = createAccordion(
        directVariationEntries,
        { header: ".variation-header", content: ".variation-content", narrative: ".variation-narrative" },
        undefined,
        accordionRegistry
      );
      if (controller) {
        variationControllers.set(group, controller);
      }
    });

    createAccordion(
      deviationBlock.querySelectorAll(".scar-entry"),
      { header: ".scar-header", content: ".scar-content", narrative: ".scar-narrative" },
      {
        onClose: (scarElement) => {
          // Only close variations if no variation is currently open in the registry
          // This prevents closing a variation that was just opened when the scar closed
          if (!accordionRegistry.isVariationOpen()) {
            scarElement.querySelectorAll("[data-variation-group]").forEach((group) => {
              variationControllers.get(group)?.closeAll({ instant: true });
            });
          }
        }
      },
      accordionRegistry
    );
  }
</script>
